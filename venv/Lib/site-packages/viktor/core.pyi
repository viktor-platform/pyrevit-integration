import abc
import os
import types
from .api_v1 import Entity as Entity
from .errors import SummaryError as SummaryError, UserError as UserError
from .parametrization import Parametrization as Parametrization
from .views import Summary as Summary
from _typeshed import Incomplete
from abc import ABC, ABCMeta, abstractmethod
from collections import OrderedDict
from enum import Enum
from munch import Munch as Munch
from requests_toolbelt import MultipartEncoder
from typing import Any, BinaryIO, Callable, Dict, IO, Iterable, List, Optional, Sequence, TextIO, Tuple, Type, Union

logger: Incomplete
ISCLOSE_RTOL: float
ISCLOSE_ATOL: float

class UserMessage:
    class _MessageType(Enum):
        SUCCESS: UserMessage._MessageType
        INFO: UserMessage._MessageType
        WARNING: UserMessage._MessageType
    @classmethod
    def warning(cls, message: str) -> None: ...
    @classmethod
    def info(cls, message: str) -> None: ...
    @classmethod
    def success(cls, message: str) -> None: ...

class _Context:
    job_token: Incomplete
    api_local_cache: OrderedDict
    temp_files: List[str]
    session: Incomplete
    @staticmethod
    def clear() -> None: ...

class _OrderedClass(type):
    __fields__: list
    @classmethod
    def __prepare__(mcs, name, bases): ...
    def __new__(cls, name, bases, classdict): ...

class InitialEntity:
    def __init__(self, entity_type_name: str, name: str, *, params: Union[dict, str] = ..., children: List['InitialEntity'] = ..., show_on_dashboard: bool = ...) -> None: ...

class ParamsFromFile:
    def __init__(self, *, max_size: int = ..., file_types: Sequence[str] = ...) -> None: ...
    def __call__(self, process_method: Callable) -> Callable: ...

class ViktorController(metaclass=_OrderedClass):
    label: str
    children: Optional[List[str]]
    show_children_as: Optional[str]
    summary: Optional['Summary']
    parametrization: Optional['Parametrization']
    def __init__(self, **kwargs: Any) -> None: ...

class _File(ABC, metaclass=abc.ABCMeta):
    def __init__(self, stream: IO) -> None: ...
    def close(self) -> None: ...
    @property
    def closed(self) -> bool: ...
    def fileno(self) -> int: ...
    def flush(self) -> None: ...
    def isatty(self) -> bool: ...
    @property
    def mode(self) -> str: ...
    @property
    def name(self) -> str: ...
    def readable(self) -> bool: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def seekable(self) -> bool: ...
    def tell(self) -> int: ...
    def truncate(self, size: Optional[int] = ...) -> int: ...
    def writable(self) -> bool: ...

class _TextFile(_File, TextIO, ABC, metaclass=abc.ABCMeta):
    def read(self, n: int = ...) -> str: ...
    def readline(self, limit: int = ...) -> str: ...
    def readlines(self, hint: int = ...) -> List[str]: ...
    def write(self, s: str) -> int: ...
    def writelines(self, lines: Iterable[str]) -> None: ...
    def __enter__(self) -> TextIO: ...
    def __exit__(self, t: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[types.TracebackType]) -> None: ...
    def __iter__(self) -> _TextFile: ...
    def __next__(self) -> str: ...
    @property
    def newlines(self) -> None: ...
    @property
    def buffer(self) -> BinaryIO: ...
    @property
    def encoding(self) -> str: ...
    @property
    def errors(self) -> Optional[str]: ...
    @property
    def line_buffering(self) -> int: ...

class _BinaryFile(_File, BinaryIO, ABC, metaclass=abc.ABCMeta):
    def read(self, n: int = ...) -> bytes: ...
    def readline(self, limit: int = ...) -> bytes: ...
    def readlines(self, hint: int = ...) -> List[bytes]: ...
    def write(self, s: Union[bytes, bytearray]) -> int: ...
    def writelines(self, lines: Iterable[bytes]) -> None: ...
    def __enter__(self) -> BinaryIO: ...
    def __exit__(self, t: Optional[Type[BaseException]], value: Optional[BaseException], traceback: Optional[types.TracebackType]) -> None: ...
    def __iter__(self) -> _BinaryFile: ...
    def __next__(self) -> bytes: ...

class _TextDataFile(_TextFile):
    def __init__(self, data: str) -> None: ...
    def getvalue(self) -> str: ...

class _BinaryDataFile(_BinaryFile):
    def __init__(self, data: bytes) -> None: ...
    def getvalue(self) -> bytes: ...

class _TextPathFile(_TextFile):
    def __init__(self, path: Union[str, bytes, os.PathLike], encoding: str = ...) -> None: ...

class _BinaryPathFile(_BinaryFile):
    def __init__(self, path: Union[str, bytes, os.PathLike]) -> None: ...

class _ResponseStream:
    def __init__(self, writable_stream: IO, url: str, headers: dict, binary_mode: bool, encoding: str = ...) -> None: ...
    def close(self) -> None: ...
    def __next__(self) -> Union[str, bytes]: ...
    def read(self, n: int = ...) -> Union[str, bytes]: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...

class _TextURLFile(_TextFile):
    def __init__(self, url: str, headers: dict, encoding: str = ...) -> None: ...
    def close(self) -> None: ...
    def read(self, n: int = ...) -> str: ...
    def readline(self, limit: int = ...) -> str: ...
    def readlines(self, hint: int = ...) -> List[str]: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def __next__(self) -> str: ...

class _BinaryURLFile(_BinaryFile):
    def __init__(self, url: str, headers: dict) -> None: ...
    def close(self) -> None: ...
    def read(self, n: int = ...) -> bytes: ...
    def readline(self, limit: int = ...) -> bytes: ...
    def readlines(self, hint: int = ...) -> List[bytes]: ...
    def seek(self, offset: int, whence: int = ...) -> int: ...
    def __next__(self) -> bytes: ...

class _TextWritableFile(_TextFile):
    def __init__(self, path: Union[str, bytes, os.PathLike], encoding: str = ...) -> None: ...
    def write(self, s: str) -> int: ...

class _BinaryWritableFile(_BinaryFile):
    def __init__(self, path: Union[str, bytes, os.PathLike]) -> None: ...
    def write(self, s: Union[bytes, bytearray]) -> int: ...

class _FileManager(ABC, metaclass=abc.ABCMeta):
    @property
    @abstractmethod
    def source(self) -> Optional[str]: ...
    @property
    @abstractmethod
    def writable(self) -> bool: ...
    @abstractmethod
    def create_text_file(self, encoding: str = ...) -> TextIO: ...
    @abstractmethod
    def create_binary_file(self) -> BinaryIO: ...

class _DataFileManager(_FileManager):
    source: Incomplete
    writable: bool
    def __init__(self, data: Union[str, bytes]) -> None: ...
    def create_text_file(self, encoding: str = ...) -> _TextFile: ...
    def create_binary_file(self) -> _BinaryFile: ...

class _PathFileManager(_FileManager):
    writable: bool
    def __init__(self, path: Union[str, bytes, os.PathLike]) -> None: ...
    @property
    def source(self) -> str: ...
    def create_text_file(self, encoding: str = ...) -> _TextFile: ...
    def create_binary_file(self) -> _BinaryFile: ...

class _URLFileManager(_FileManager):
    writable: bool
    def __init__(self, url: str, headers: Optional[dict]) -> None: ...
    @property
    def source(self) -> str: ...
    def create_text_file(self, encoding: str = ...) -> _TextURLFile: ...
    def create_binary_file(self) -> _BinaryURLFile: ...

class _WritableFileManager(_FileManager):
    writable: bool
    def __init__(self) -> None: ...
    @property
    def source(self) -> str: ...
    def create_text_file(self, encoding: str = ...) -> _TextWritableFile: ...
    def create_binary_file(self) -> _BinaryWritableFile: ...

class File:
    class SourceType(Enum):
        DATA: File.SourceType
        PATH: File.SourceType
        URL: File.SourceType
        WRITABLE: File.SourceType
    def __init__(self, *, data: Union[str, bytes] = ..., path: Union[str, bytes, os.PathLike] = ..., url: str = ..., **kwargs: Any) -> None: ...
    @classmethod
    def from_data(cls, data: Union[str, bytes]) -> File: ...
    @classmethod
    def from_path(cls, path: Union[str, bytes, os.PathLike]) -> File: ...
    @classmethod
    def from_url(cls, url: str, *, headers: dict = ...) -> File: ...
    @property
    def source(self) -> Optional[str]: ...
    @property
    def source_type(self) -> SourceType: ...
    @property
    def writable(self) -> bool: ...
    def open(self, encoding: str = ...) -> TextIO: ...
    def open_binary(self) -> BinaryIO: ...
    def getvalue(self, encoding: str = ...) -> str: ...
    def getvalue_binary(self) -> bytes: ...
    def copy(self, writable: bool = ...) -> File: ...

class _MultipartEncoder(MultipartEncoder):
    def __init__(self, data: dict, file: BinaryIO) -> None: ...

class Color:
    def __new__(cls, r: int, g: int, b: int) -> Color: ...
    def __copy__(self) -> Color: ...
    def __deepcopy__(self, memo: dict) -> Color: ...
    @staticmethod
    def black() -> Color: ...
    @staticmethod
    def white() -> Color: ...
    @staticmethod
    def red() -> Color: ...
    @staticmethod
    def lime() -> Color: ...
    @staticmethod
    def green() -> Color: ...
    @staticmethod
    def blue() -> Color: ...
    @staticmethod
    def viktor_black() -> Color: ...
    @staticmethod
    def viktor_blue() -> Color: ...
    @staticmethod
    def viktor_yellow() -> Color: ...
    @classmethod
    def from_hex(cls, hex_value: str) -> Color: ...
    @classmethod
    def from_deltares(cls, value: int) -> Color: ...
    @staticmethod
    def random() -> Color: ...
    @property
    def rgb(self) -> Tuple[int, int, int]: ...
    @property
    def hex(self) -> str: ...
    @property
    def deltares(self) -> int: ...
    @staticmethod
    def rgb_to_hex(r: int, g: int, b: int, include_hashtag: bool = ...) -> str: ...
    @staticmethod
    def hex_to_rgb(hex_value: str) -> Tuple[int, int, int]: ...
    @staticmethod
    def rgb_to_deltares(r: int, g: int, b: int) -> int: ...
    @staticmethod
    def deltares_to_rgb(value: int) -> Tuple[int, int, int]: ...

class _SerializableObject(metaclass=ABCMeta): ...

def progress_message(message: str, percentage: float = ...) -> None: ...
def make_data_json_serializable(input_data: Any) -> Any: ...

class Storage:
    def __init__(self) -> None: ...
    def set(self, key: str, data: File, *, scope: str, entity: Entity = ...) -> None: ...
    def get(self, key: str, *, scope: str, entity: Entity = ...) -> File: ...
    def delete(self, key: str, *, scope: str, entity: Entity = ...) -> None: ...
    def list(self, *, prefix: str = ..., scope: str, entity: Entity = ...) -> Dict[str, File]: ...

class _MovedClass:
    new_class: Incomplete
    message: Incomplete
    upgrade_id: Incomplete
    def __init__(self, new_class: Type, message: str, upgrade_id: int) -> None: ...
    def __call__(self, *args: Any, **kwargs: Any) -> Any: ...
    def __getattr__(self, attr: Any) -> Any: ...
    def __instancecheck__(self, instance: Any) -> bool: ...

import abc
from ..core import File as File
from ..errors import ModelError as ModelError
from .external_program import ExternalProgram as ExternalProgram
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from enum import Enum
from io import BytesIO
from typing import Any, Dict, Iterator, List, Optional, Tuple, Union

class AxisVMAnalysis(ExternalProgram):
    def __init__(self, model: Model, *, return_results: bool = ..., return_model: bool = ..., report_template: Union[BytesIO, File] = ...) -> None: ...
    def get_results(self) -> dict: ...
    def get_model_file(self, *, as_file: bool = ...) -> Optional[Union[BytesIO, File]]: ...
    def get_result_file(self, *, as_file: bool = ...) -> Optional[Union[BytesIO, File]]: ...

class _Point3D:
    x: Incomplete
    y: Incomplete
    z: Incomplete
    def __init__(self, x: float, y: float, z: float) -> None: ...
    @classmethod
    def from_tuple(cls, xyz: Tuple[float, float, float]) -> _Point3D: ...
    def serialize(self) -> dict: ...

class CircleArc:
    center: Incomplete
    normal_vector: Incomplete
    alpha: Incomplete
    def __init__(self, center: Tuple[float, float, float], normal_vector: Tuple[float, float, float], alpha: float) -> None: ...

class _InstructionList:
    def __init__(self) -> None: ...
    def add_function(self, name: str, parameters: dict) -> None: ...
    def add_property(self, name: str, value: Any) -> None: ...
    def serialize(self) -> dict: ...

class Object(ABC):
    def __init__(self, id_: int) -> None: ...
    @property
    def id(self) -> int: ...

class Reference(Object, ABC, metaclass=abc.ABCMeta):
    class _Type(Enum):
        POINT: Reference._Type
        VECTOR: Reference._Type
        AXIS: Reference._Type
        PLANE: Reference._Type
        ANGLE: Reference._Type

class _ReferencePoint(Reference):
    x: Incomplete
    y: Incomplete
    z: Incomplete
    def __init__(self, id_: int, x: float, y: float, z: float) -> None: ...

class _ReferenceVector(Reference):
    point_1: Incomplete
    point_2: Incomplete
    def __init__(self, id_: int, point_1: Tuple[float, float, float], point_2: Tuple[float, float, float]) -> None: ...

class _ReferenceAxis(Reference):
    point_1: Incomplete
    point_2: Incomplete
    def __init__(self, id_: int, point_1: Tuple[float, float, float], point_2: Tuple[float, float, float]) -> None: ...

class _ReferencePlane(Reference):
    point_1: Incomplete
    point_2: Incomplete
    point_3: Incomplete
    def __init__(self, id_: int, point_1: Tuple[float, float, float], point_2: Tuple[float, float, float], point_3: Tuple[float, float, float]) -> None: ...

class _ReferenceAngle(Reference):
    angle: Incomplete
    def __init__(self, id_: int, angle: float) -> None: ...

class _ReferenceData:
    point: Incomplete
    vector: Incomplete
    axis: Incomplete
    plane: Incomplete
    angle: Incomplete
    def __init__(self, point: _ReferencePoint = ..., vector: _ReferenceVector = ..., axis: _ReferenceAxis = ..., plane: _ReferencePlane = ..., angle: _ReferenceAngle = ...) -> None: ...
    def serialize(self) -> dict: ...

class Material(Object):
    class DesignCode(Enum):
        OTHER: Material.DesignCode
        HUNGARIAN_MSZ: Material.DesignCode
        EURO_CODE: Material.DesignCode
        ROMANIAN_STAS: Material.DesignCode
        DUTCH_NEN: Material.DesignCode
        GERMAN_DIN1045_1: Material.DesignCode
        SWISS_SIA26X: Material.DesignCode
        EURO_CODE_GER: Material.DesignCode
        ITALIAN: Material.DesignCode
        EURO_CODE_AUSTRIAN: Material.DesignCode
        EURO_CODE_UK: Material.DesignCode
        EURO_CODE_NL: Material.DesignCode
        EURO_CODE_FIN: Material.DesignCode
        EURO_CODE_RO: Material.DesignCode
        EURO_CODE_HU: Material.DesignCode
        EURO_CODE_CZ: Material.DesignCode
        EURO_CODE_B: Material.DesignCode
        EURO_CODE_PL: Material.DesignCode
        EURO_CODE_DK: Material.DesignCode
        EURO_CODE_S: Material.DesignCode
        US: Material.DesignCode
        CA_NBCC: Material.DesignCode
        CA_ONTARIO: Material.DesignCode
        CA_BRIDGE: Material.DesignCode
        EURO_CODE_SK: Material.DesignCode
    def __init__(self, id_: int, name: str) -> None: ...
    @property
    def name(self) -> str: ...

class Node(Object):
    def __init__(self, id_: int, x: float, y: float, z: float) -> None: ...
    @property
    def x(self) -> float: ...
    @property
    def y(self) -> float: ...
    @property
    def z(self) -> float: ...

class CrossSection(Object):
    class Process(Enum):
        OTHER: CrossSection.Process
        ROLLED: CrossSection.Process
        WELDED: CrossSection.Process
        COLD_FORMED: CrossSection.Process
    def __init__(self, id_: int, name: str) -> None: ...
    @property
    def name(self) -> str: ...

class Line(Object):
    class _GeomType(Enum):
        STRAIGHT_LINE: Line._GeomType
        CIRCLE_ARC: Line._GeomType
    def __init__(self, id_: int, interface: LineInterface, node1: Node, node2: Node) -> None: ...
    @property
    def start_node(self) -> Node: ...
    @property
    def end_node(self) -> Node: ...
    def define_as_beam(self, material: Material, css_start: CrossSection, css_end: CrossSection = ..., *, local_z_reference: Reference = ...) -> Member: ...
    def split_by_number(self, n: int) -> None: ...

class Member(Object):
    class _Type(Enum):
        BEAM: Member._Type
        RIB: Member._Type
    def __init__(self, line: Line, type_: _Type) -> None: ...

class Domain(Object):
    class SurfaceType(Enum):
        HOLE: Domain.SurfaceType
        MEMBRANE_STRESS: Domain.SurfaceType
        MEMBRANE_STRAIN: Domain.SurfaceType
        PLATE: Domain.SurfaceType
        SHELL: Domain.SurfaceType
    class MeshType(Enum):
        ADAPTIVE: Domain.MeshType
        UNIFORM: Domain.MeshType
    class MeshGeometry(Enum):
        TRIANGLE: Domain.MeshGeometry
        QUAD: Domain.MeshGeometry
        MIXED: Domain.MeshGeometry
    class EccentricityType(Enum):
        CONSTANT: Domain.EccentricityType
        ONE_WAY: Domain.EccentricityType
        TWO_WAY: Domain.EccentricityType
        TOP_ALIGNED: Domain.EccentricityType
        BOTTOM_ALIGNED: Domain.EccentricityType
    def __init__(self, id_: int, interface: DomainInterface) -> None: ...
    def generate_mesh(self, mesh_geometry: MeshGeometry, mesh_size: float, *, mesh_type: MeshType = ..., fit_to_point_loads: float = ..., fit_to_line_loads: float = ..., fit_to_surface_loads: float = ..., quad_mesh_quality: int = ...) -> None: ...
    def set_eccentricity(self, eccentricity_type: EccentricityType, *, ecc_1: float = ..., p1: Tuple[float, float, float] = ..., ecc_2: float = ..., p2: Tuple[float, float, float] = ..., ecc_3: float = ..., p3: Tuple[float, float, float] = ...) -> None: ...

class NodeSupport(Object): ...

class LineSupport(Object):
    class NonLinearity(Enum):
        LINEAR: LineSupport.NonLinearity
        TENSION_ONLY: LineSupport.NonLinearity
        COMPRESSION_ONLY: LineSupport.NonLinearity

class LoadCase(Object):
    class _Type(Enum):
        STANDARD: LoadCase._Type
    def __init__(self, id_: int, name: str) -> None: ...
    @property
    def name(self) -> str: ...

class Load(Object):
    class DistributionType(Enum):
        GLOBAL: Load.DistributionType
        LOCAL: Load.DistributionType
        PROJECTED: Load.DistributionType
    class SurfaceDistributionType(Enum):
        SURFACE: Load.SurfaceDistributionType
        PROJECTED: Load.SurfaceDistributionType
    class System(Enum):
        GLOBAL: Load.System
        LOCAL: Load.System
        REFERENCE: Load.System
    class _LoadDistributionType(Enum):
        CONSTANT: Load._LoadDistributionType
        LINEAR: Load._LoadDistributionType
    class Axis(Enum):
        X: Load.Axis
        Y: Load.Axis
        Z: Load.Axis
        XX: Load.Axis
        YY: Load.Axis
        ZZ: Load.Axis

class LoadCombination(Object):
    class Type(Enum):
        OTHER: LoadCombination.Type
        SLS_1: LoadCombination.Type
        SLS_CHAR: LoadCombination.Type
        SLS_2: LoadCombination.Type
        SLS_FREQ: LoadCombination.Type
        SLS_3: LoadCombination.Type
        SLS_QUASI: LoadCombination.Type
        ULS_1: LoadCombination.Type
        ULS: LoadCombination.Type
        ULS_2: LoadCombination.Type
        ULS_SEISMIC: LoadCombination.Type
        ULS_3: LoadCombination.Type
        ULS_EXCEPTIONAL: LoadCombination.Type
        ULS_ALL: LoadCombination.Type
        ULS_AB: LoadCombination.Type
        ULS_A: LoadCombination.Type
        ULS_B: LoadCombination.Type
        ULS_ALL_AB: LoadCombination.Type
        ULS_A1: LoadCombination.Type
        ULS_A2: LoadCombination.Type
        ULS_A3: LoadCombination.Type
        ULS_A4: LoadCombination.Type
        ULS_A5: LoadCombination.Type
        ULS_A6: LoadCombination.Type
        ULS_A7: LoadCombination.Type
        ULS_A8: LoadCombination.Type
    def __init__(self, id_: int, name: str) -> None: ...
    @property
    def name(self) -> str: ...

class _Calculation(Object):
    class UserInteraction(Enum):
        USER_INTERACTION: _Calculation.UserInteraction
        AUTO_CORRECT: _Calculation.UserInteraction
        NO_AUTO_CORRECT: _Calculation.UserInteraction
        AUTO_CORRECT_NO_SHOW: _Calculation.UserInteraction
        NO_AUTO_CORRECT_NO_SHOW: _Calculation.UserInteraction

class Section(Object):
    class _Type(Enum):
        PLANE: Section._Type
        SEGMENT: Section._Type
    def __init__(self, id_: int, interface: SectionInterface, name: str) -> None: ...
    @property
    def name(self) -> str: ...

class _Interface(ABC, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    @abstractmethod
    def __contains__(self, o: object) -> bool: ...
    @abstractmethod
    def __getitem__(self, i: int): ...
    @abstractmethod
    def __iter__(self): ...
    @abstractmethod
    def __len__(self) -> int: ...

class ReferenceInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> Reference: ...
    def __iter__(self) -> Iterator[Reference]: ...
    def __len__(self) -> int: ...
    def create_point(self, x: float, y: float, z: float) -> Reference: ...
    def create_vector(self, point_1: Tuple[float, float, float], point_2: Tuple[float, float, float]) -> Reference: ...
    def create_axis(self, point_1: Tuple[float, float, float], point_2: Tuple[float, float, float]) -> Reference: ...
    def create_plane(self, point_1: Tuple[float, float, float], point_2: Tuple[float, float, float], point_3: Tuple[float, float, float]) -> Reference: ...
    def create_angle(self, angle: float) -> Reference: ...

class MaterialInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> Material: ...
    def __iter__(self) -> Iterator[Material]: ...
    def __len__(self) -> int: ...
    def create_concrete_eurocode(self, *, e_x: float, e_y: float = ..., e_z: float = ..., nu_x: float, nu_y: float = ..., nu_z: float = ..., alpha_x: float = ..., alpha_y: float = ..., alpha_z: float = ..., rho: float, f_ck: float, gamma_c: float, alpha_cc: float, phi_t: float = ..., material_code: str = ..., name: str = ...) -> Material: ...
    def add_from_catalog(self, name: str, national_design_code: Material.DesignCode) -> Material: ...

class NodeInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> Node: ...
    def __iter__(self) -> Iterator[Node]: ...
    def __len__(self) -> int: ...
    def create(self, x: float, y: float, z: float) -> Node: ...

class CrossSectionInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> CrossSection: ...
    def __iter__(self) -> Iterator[CrossSection]: ...
    def __len__(self) -> int: ...
    def create_circular(self, diameter: float, *, name: str = ...) -> CrossSection: ...
    def create_rectangular(self, width: float, height: float, *, process: CrossSection.Process = ..., name: str = ...) -> CrossSection: ...

class LineInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> Line: ...
    def __iter__(self) -> Iterator[Line]: ...
    def __len__(self) -> int: ...
    def __init__(self) -> None: ...
    def create(self, start_node: Node, end_node: Node, circle_arc: CircleArc = ...) -> Line: ...
    def define_as_beam(self, line: Line, material: Material, css_start: CrossSection, css_end: CrossSection = ..., *, local_z_reference: Reference = ...) -> Member: ...
    def split_by_number(self, line: Line, n: int) -> None: ...

class DomainInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> Domain: ...
    def __iter__(self) -> Iterator[Domain]: ...
    def __len__(self) -> int: ...
    def create(self, lines: List[Line], *, surface_type: Domain.SurfaceType, thickness: float, material: Material) -> Domain: ...
    def generate_mesh_on_domains(self, domains: List[Domain], mesh_geometry: Domain.MeshGeometry, mesh_size: float, *, mesh_type: Domain.MeshType = ..., fit_to_point_loads: float = ..., fit_to_line_loads: float = ..., fit_to_surface_loads: float = ..., quad_mesh_quality: int = ...) -> None: ...
    def set_eccentricity(self, domain: Domain, eccentricity_type: Domain.EccentricityType, *, ecc_1: float = ..., p1: Tuple[float, float, float] = ..., ecc_2: float = ..., p2: Tuple[float, float, float] = ..., ecc_3: float = ..., p3: Tuple[float, float, float] = ...) -> None: ...

class NodeSupportInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> NodeSupport: ...
    def __iter__(self) -> Iterator[NodeSupport]: ...
    def __len__(self) -> int: ...
    def __init__(self, lines: LineInterface) -> None: ...
    def create_relative_to_member(self, node: Node, *, stiffness_x: float = ..., stiffness_y: float = ..., stiffness_z: float = ..., stiffness_xx: float = ..., stiffness_yy: float = ..., stiffness_zz: float = ..., resistance_x: float = ..., resistance_y: float = ..., resistance_z: float = ..., resistance_xx: float = ..., resistance_yy: float = ..., resistance_zz: float = ..., non_linearity_x: LineSupport.NonLinearity = ..., non_linearity_y: LineSupport.NonLinearity = ..., non_linearity_z: LineSupport.NonLinearity = ..., non_linearity_xx: LineSupport.NonLinearity = ..., non_linearity_yy: LineSupport.NonLinearity = ..., non_linearity_zz: LineSupport.NonLinearity = ...) -> NodeSupport: ...

class LineSupportInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> LineSupport: ...
    def __iter__(self) -> Iterator[LineSupport]: ...
    def __len__(self) -> int: ...
    def create_on_member(self, member: Member, k_x: float, k_y: float, k_z: float, *, non_linearity_x: LineSupport.NonLinearity = ..., non_linearity_y: LineSupport.NonLinearity = ..., non_linearity_z: LineSupport.NonLinearity = ..., resistance_fx: float = ..., resistance_fy: float = ..., resistance_fz: float = ...) -> LineSupport: ...

class LoadCaseInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> LoadCase: ...
    def __iter__(self) -> Iterator[LoadCase]: ...
    def __len__(self) -> int: ...
    def create(self, name: str = ...) -> LoadCase: ...

class LoadInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> Load: ...
    def __iter__(self) -> Iterator[Load]: ...
    def __len__(self) -> int: ...
    def create_domain_linear(self, load_case: LoadCase, domain: Domain, load: Tuple[float, float, float], *, component: Load.Axis, point_1: Tuple[float, float, float], point_2: Tuple[float, float, float], point_3: Tuple[float, float, float], distribution_type: Load.DistributionType = ..., load_on_hole: bool = ...) -> Load: ...
    def create_domain_constant(self, load_case: LoadCase, domain: Domain, load: Tuple[float, float, float], *, distribution_type: Load.SurfaceDistributionType = ..., system: Load.System = ...) -> Load: ...
    def create_domain_self_weight(self, load_case: LoadCase, domain: Domain) -> Load: ...
    def create_beam_self_weight(self, load_case: LoadCase, member: Member) -> Load: ...

class LoadCombinationInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> LoadCombination: ...
    def __iter__(self) -> Iterator[LoadCombination]: ...
    def __len__(self) -> int: ...
    def create(self, combination_type: LoadCombination.Type, load_case_factors: Dict[LoadCase, float], *, name: str = ...) -> LoadCombination: ...

class SectionInterface(_Interface):
    def __contains__(self, o: object) -> bool: ...
    def __getitem__(self, i: int) -> Section: ...
    def __iter__(self) -> Iterator[Section]: ...
    def __len__(self) -> int: ...
    def create(self, start_point: Tuple[float, float, float], end_point: Tuple[float, float, float], normal_vector: Tuple[float, float, float], *, name: str = ...) -> Section: ...

class ResultInterface:
    def __init__(self, nodes: NodeInterface, node_supports: NodeSupportInterface, lines: LineInterface, sections: SectionInterface) -> None: ...
    def nodal_displacements(self, nodes: List[Node] = ..., *, by_load_case: bool = ...) -> None: ...
    def nodal_support_forces(self, node_supports: List[NodeSupport] = ..., *, by_load_case: bool = ...) -> None: ...
    def line_forces(self, members: List[Member] = ..., *, by_load_case: bool = ...) -> None: ...
    def section_surface_forces(self, sections: List[Section], cases: List[LoadCombination], chain_index: int = ...) -> None: ...
    def section_surface_stresses(self, sections: List[Section], cases: List[LoadCombination], chain_index: int = ...) -> None: ...

class _CalculationInterface:
    instructions: Incomplete
    def __init__(self) -> None: ...
    def create_linear_analysis(self) -> None: ...

class Model:
    def __init__(self) -> None: ...
    @property
    def references(self) -> ReferenceInterface: ...
    @property
    def materials(self) -> MaterialInterface: ...
    @property
    def nodes(self) -> NodeInterface: ...
    @property
    def cross_sections(self) -> CrossSectionInterface: ...
    @property
    def lines(self) -> LineInterface: ...
    @property
    def domains(self) -> DomainInterface: ...
    @property
    def node_supports(self) -> NodeSupportInterface: ...
    @property
    def line_supports(self) -> LineSupportInterface: ...
    @property
    def load_cases(self) -> LoadCaseInterface: ...
    @property
    def loads(self) -> LoadInterface: ...
    @property
    def load_combinations(self) -> LoadCombinationInterface: ...
    @property
    def sections(self) -> SectionInterface: ...
    @property
    def results(self) -> ResultInterface: ...
